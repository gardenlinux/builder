#!/usr/bin/env bash

set -Eeufo pipefail

veritytab=
cert_base="/builder/cert/secureboot.db"
timestamp=0
secureboot="true"
dracut_include=
tpm2=

while [ $# -gt 0 ]; do
	case "$1" in
		-r|--rootfs)
			rootfs="$2"
			shift 2
			;;
		-c|--cmdline)
			cmdline="$2"
			shift 2
			;;
		-v|--veritytab)
			veritytab="$2"
			shift 2
			;;
		--cert)
			cert_base="${2%.crt}"
			if [ -n "$cert_base" ] && [ "$cert_base.crt" != "$2" ]; then
				echo "cert file must end in .crt" >&2
				exit 1
			fi
			shift 2
			;;
		-t|--timestamp)
			timestamp="$2"
			shift 2
			;;
		-s|--secureboot)
			secureboot="$2"
			shift 2
			;;
		--tpm2)
			tpm2="tpm2-tss"
			shift
			;;
		-i|--include)
			dracut_include="$2"
			shift 2
			;;
		*)
			break
			;;
	esac
done

initrd="$(mktemp)"
unified_image="$(mktemp)"
unified_image_signed="$(mktemp)"

[ ! -e "$rootfs$initrd" ]
touch "$rootfs$initrd"
mount --bind "$initrd" "$rootfs$initrd"
[ ! -e "$rootfs$dracut_include" ]
mkdir -p "$rootfs$dracut_include"
mount --bind "$dracut_include" "$rootfs$dracut_include"
[ ! -s "$rootfs/etc/veritytab" ]
touch "$rootfs/etc/veritytab"
[ -z "$veritytab" ] || mount --bind "$veritytab" "$rootfs/etc/veritytab"
[ -d "$rootfs/proc" ]
mount --rbind /proc "$rootfs/proc"
[ -d "$rootfs/dev" ]
mount --rbind /dev "$rootfs/dev"

kernel_file=$(find "$rootfs/boot/" -name 'vmlinuz-*')
kernel_version="${kernel_file#*-}"

unshare --user --map-root-user --mount -- bash -c 'mount -t tmpfs -o size='"$TEMPFS_SIZE"' tmpfs '"$rootfs/var/tmp"' && mount -t tmpfs -o size='"$TEMPFS_SIZE"' tmpfs /sys && mount --bind /usr/bin/false /usr/bin/systemd-detect-virt && "$@"' -- \
chroot "$rootfs" env dracut \
	--no-hostonly \
	--force \
	--kver "$kernel_version" \
	--modules "bash dash systemd systemd-initrd systemd-veritysetup systemd-repart kernel-modules kernel-modules-extra terminfo udev-rules dracut-systemd base fs-lib shutdown crypt systemd-pcrphase $tpm2" \
	--install "/etc/veritytab cryptsetup head mkfs.ext4 systemd-escape lsblk" \
	--include "$dracut_include" "/" \
	--reproducible \
	"$initrd"

umount -l "$rootfs/dev"
umount -l "$rootfs/proc"
umount "$rootfs$initrd"
rm "$rootfs$initrd"
umount "$rootfs$dracut_include"
rmdir "$rootfs$dracut_include"
umount "$rootfs/etc/veritytab"
rm "$rootfs/etc/veritytab"

case "$BUILDER_ARCH" in
	amd64)
		uefi_arch=X64
		gnu_arch=x86_64
		;;
	arm64)
		uefi_arch=AA64
		gnu_arch=aarch64
		;;
esac

# pre-calculate PCR11 values
unified_image_tmp="$(mktemp)"
pcr_tmp="$(mktemp)"

pcr_pub_key="/builder/cert/tpm2-pcr-public.pem"
pcr_priv_key="/builder/cert/tpm2-pcr-private.pem"

/usr/lib/systemd/ukify build \
	--stub "$rootfs/usr/lib/systemd/boot/efi/linux$(tr '[:upper:]' '[:lower:]' <<< "$uefi_arch").efi.stub" \
	--linux "$kernel_file" \
	--initrd "$initrd" \
	--cmdline "$cmdline" \
	--output "$unified_image_tmp" \
	--os-release "@$rootfs/etc/os-release" \
	--pcrpkey "$pcr_pub_key" \
	--pcr-banks "sha256" \
	--measure > "$pcr_tmp"

# generate .pcrsig section
pcr_sig="$(mktemp)"

cat >> "$pcr_sig" << EOF
{
  "sha256" : [
EOF

pcr_counter=0
while read pcr_line; do
    # Split the string at the "="
    IFS='=' read -ra PCR <<< $pcr_line
    echo "${PCR[1]}"

    if (( pcr_counter == 3 )); then
      trailing_comma=""
    else
      trailing_comma=","
    fi

    # Calculate the PCR policy digest
    policy_init=$(printf '%0*d' 64 0)

    command_code="0000017f"
    hash_alg_id="000B"

    pcr_index="11"
    pcr_value_hash=$(echo -n "${PCR[1]}" | xxd -r -p | openssl dgst -sha256 -binary | xxd -p -c 256)

    pcr_select_bit_map=("00" "00" "00")
    pcr_select_bit_map[$((pcr_index / 8))]=$(printf "%02x" $((1 << pcr_index % 8)))

    pcr_selection=$(printf "00000001%s03%s%s%s" "$hash_alg_id" "${pcr_select_bit_map[0]}" "${pcr_select_bit_map[1]}" "${pcr_select_bit_map[2]}")
    policy="${policy_init}$command_code$pcr_selection$pcr_value_hash"

    policy_digest=$(echo -n "$policy" | xxd -r -p | openssl dgst -sha256 -binary | xxd -p -c 256)
		# ***

    cat >> "$pcr_sig" << EOF
    {
      "pcrs" : [
        11
      ],
      "pkfp" : "$(openssl pkey -pubin -inform PEM -outform DER -in "$pcr_pub_key" | tail -c +25 | openssl dgst -sha256 -hex | awk '{print $2}')",
      "pol" : "$policy_digest",
      "sig" : "$(echo -n "$policy_digest" | xxd -r -p | openssl dgst -sha256 -sign "$pcr_priv_key" | openssl base64 -A)"
    }$trailing_comma
EOF

	  pcr_counter=$((pcr_counter+1))

    if (( pcr_counter == 4 )); then
      break
    fi
done < $pcr_tmp

cat >> "$pcr_sig" << EOF
  ]
}
EOF

# create unified image
/usr/lib/systemd/ukify build \
	--stub "$rootfs/usr/lib/systemd/boot/efi/linux$(tr '[:upper:]' '[:lower:]' <<< "$uefi_arch").efi.stub" \
	--linux "$kernel_file" \
	--initrd "$initrd" \
	--cmdline "$cmdline" \
	--output "$unified_image" \
	--os-release "@$rootfs/etc/os-release" \
	--pcrpkey "$pcr_pub_key" \
	--section ".pcrsig:@$pcr_sig"

rm $unified_image_tmp
rm $pcr_tmp
rm $pcr_sig

efi_dir="$(mktemp -d)"
mkdir -p "$efi_dir/EFI/BOOT/"

if [[ "$secureboot" = "true" ]]; then
	if [ -f "$cert_base.key" ]; then
		key_params=(--key "$cert_base.key")
	elif [ -f "$cert_base.arn" ]; then
		PKCS11_MODULE_PATH="/usr/lib/$(uname -m)-linux-gnu/pkcs11/aws_kms_pkcs11.so"
		export PKCS11_MODULE_PATH
		key_params=(--engine pkcs11 --key "pkcs11:token=$(basename "$(cat "$cert_base.arn")" | cut -c -32)")
	else
		echo "neither $cert_base.key nor $cert_base.arn exists, but at least one is required" >&2
		exit 1
	fi

	# sign unified image
	datefudge -s "@$timestamp" sbsign --cert "$cert_base.crt" "${key_params[@]}" --output "$unified_image_signed" "$unified_image"
	rm "$unified_image"

	ls -lah "$unified_image_signed"

	mv "$unified_image_signed" "$efi_dir/EFI/BOOT/BOOT$uefi_arch.EFI"
else
	mv "$unified_image" "$efi_dir/EFI/BOOT/BOOT$uefi_arch.EFI"
fi

while read -r partition_file; do
	if [[ "$BUILDER_ARCH" = "amd64" ]] && [[ ! "$secureboot" = "true" ]]; then
	# add roothash to legacy boot kernel cmdline
		syslinux=$(mktemp)
		mcopy -i "$partition_file" -p ::/syslinux/syslinux.cfg "$syslinux"
		sed -i "s/root=[^ ]*/$(echo "$cmdline" | cut -d ' ' -f 1)/g" "$syslinux"
		mcopy -i "$partition_file" -po "$syslinux" ::/syslinux/syslinux.cfg
	# copy initrd.img for legacy boot when secureboot feature is not enabled
		datefudge -s "@$timestamp" mcopy -i "$partition_file" -o -p "$initrd" "::/Default/${kernel_version}/initrd.img-${kernel_version}"
	fi
	if [[ ! "$secureboot" = "true" ]]; then
	# clean up EFI directory
		mdeltree -i "$partition_file" ::/EFI
	fi
	# copy unified image to uefi partition
	datefudge -s "@$timestamp" mcopy -i "$partition_file" -s -p "$efi_dir/EFI" "::/EFI"
done

rm "$initrd"
rm -rf "$efi_dir"
